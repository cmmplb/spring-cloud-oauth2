# Feign和JWT令牌对称、非对称加密配置

## Feign

之前服务调用都是使用RestTemplate，现在添加Feign来调用，在feign服务调用需要添加认证请求头。

- 添加系统模块的api服务，用于提供系统模块的接口feign

- 在spring-cloud-oauth2目录下创建spring-cloud-oauth2-system-api文件夹。

- 创建包目录com.cmmplb.oauth2.system.server.api

- 添加pom.xml文件

````xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!-- 父工程 -->
    <parent>
        <artifactId>spring-cloud-oauth2</artifactId>
        <groupId>com.cmmplb</groupId>
        <version>1.0.0</version>
    </parent>
    <!-- 指定当前POM模型的版本 -->
    <modelVersion>4.0.0</modelVersion>
    <!-- 项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。 -->
    <artifactId>spring-cloud-oauth2-system-server-api</artifactId>
    <!-- 项目的打包类型：pom、jar、war -->
    <packaging>jar</packaging>
    <!-- 项目名称 -->
    <name>${project.artifactId}</name>
    <!-- 描述信息 -->
    <description>系统api模块</description>

    <!-- 依赖 -->
    <dependencies>
        <!-- openfeign -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <!-- loadbalancer -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </dependency>
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>
</project>
````

- 创建PermissionFeignClient。

`spring-cloud-oauth2/spring-cloud-oauth2-system-server-api/src/main/java/com/cmmplb/oauth2/system/server/api/client/PermissionFeignClient.java`

````java
package com.cmmplb.oauth2.system.server.api.client;

import com.cmmplb.oauth2.system.server.api.client.fallback.PermissionFeignClientFallBack;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

/**
 * @author penglibo
 * @date 2024-07-31 11:29:37
 * @since jdk 1.8
 */

@FeignClient(contextId = "permission-feign", name = "spring-cloud-oauth2-system-server", path = "/permission", fallbackFactory = PermissionFeignClientFallBack.class)
public interface PermissionFeignClient {

    /**
     * 需要有write编码权限
     */
    @GetMapping("/write")
    String write();

    /**
     * 需要有read编码权限
     */
    @GetMapping("/read")
    String read();

    /**
     * 需要有普通用户角色权限
     */
    @GetMapping("/user")
    String user();

    /**
     * 需要有管理员角色权限
     */
    @GetMapping("/admin")
    String admin();

}
````

- 创建PermissionFeignClientFallBack服务熔断降级。

````java
package com.cmmplb.oauth2.system.server.api.client.fallback;

import com.cmmplb.oauth2.system.server.api.client.PermissionFeignClient;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.openfeign.FallbackFactory;

/**
 * @author penglibo
 * @date 2024-07-31 11:30:02
 * @since jdk 1.8
 * 服务熔断降级处理
 */

@Slf4j
public class PermissionFeignClientFallBack implements FallbackFactory<PermissionFeignClient> {
    @Override
    public PermissionFeignClient create(Throwable cause) {
        log.error("服务调用失败:{}", cause.getMessage());
        return new PermissionFeignClient() {

            @Override
            public String write() {
                return "error";
            }

            @Override
            public String read() {
                return "error";
            }

            @Override
            public String user() {
                return "error";
            }

            @Override
            public String admin() {
                return "error";
            }
        };
    }
}
````

- 在父工程定义系统模块api版本

`spring-cloud-oauth2/pom.xml`

````xml
<!-- 依赖管理 -->
<dependencyManagement>
    <dependencies>
        <!-- 系统服务api模块 -->
        <dependency>
            <groupId>com.cmmplb</groupId>
            <artifactId>spring-cloud-oauth2-system-server-api</artifactId>
            <version>1.0.0</version>
        </dependency>
        <!-- ... -->
    </dependencies>
</dependencyManagement>
````

- 认证服务模块引入系统模块api

`spring-cloud-oauth2/spring-cloud-oauth2-auth-server/pom.xml`

````xml
<!-- 依赖 -->
<dependencies>
    <!-- 系统服务api模块 -->
    <dependency>
        <groupId>com.cmmplb</groupId>
        <artifactId>spring-cloud-oauth2-system-server-api</artifactId>
    </dependency>
    <!-- ... -->
</dependencies>
````

启动类添加@EnableFeignClients注解

`spring-cloud-oauth2/spring-cloud-oauth2-auth-server/src/main/java/com/cmmplb/oauth2/auth/server/AuthServerApplication.java`

````java

@EnableFeignClients("com.cmmplb.oauth2.system.server.api")
@SpringBootApplication
public class AuthServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(AuthServerApplication.class, args);
    }

}
````

- 添加controller测试服务调用效果

`spring-cloud-oauth2/spring-cloud-oauth2-auth-server/src/main/java/com/cmmplb/oauth2/auth/server/controller/RemotePermissionController.java`

````java
package com.cmmplb.oauth2.auth.server.controller;

import com.cmmplb.oauth2.system.server.api.client.PermissionFeignClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author penglibo
 * @date 2024-07-18 18:06:54
 * @since jdk 1.8
 */

@RestController
@RequestMapping("/remote/permission")
public class RemotePermissionController {

    @Autowired
    private PermissionFeignClient permissionFeignClient;

    /**
     * 需要有write编码权限
     */
    @GetMapping("/write")
    public String write() {
        return permissionFeignClient.write();
    }

    /**
     * 需要有read编码权限
     */
    @GetMapping("/read")
    public String read() {
        return permissionFeignClient.read();
    }

    /**
     * 需要有普通用户角色权限
     */
    @GetMapping("/user")
    public String user() {
        return permissionFeignClient.user();
    }

    /**
     * 需要有管理员角色权限
     */
    @GetMapping("/admin")
    public String admin() {
        return permissionFeignClient.admin();
    }
}
````

重启认证服务的时候配置配置类报错空指针。0.0，白名单认证服务没有配置，这里在SecurityProperties的白名单变量初始化一下。

`com.cmmplb.oauth2.resource.server.configuration.properties.SecurityProperties`

````java
public class SecurityProperties implements InitializingBean, ApplicationContextAware {

    private Map<String, String> whiteList = new HashMap<>();

    // ...
}
````

````shell
curl --location 'http://localhost:10000/auth/remote/permission/write' \
--header 'Authorization: bearer e11d806a-e963-4e2c-a415-18164981e169' \
````

报错服务器繁忙，看控制日志是打印未登录，也就是feign调用时请求头没有携带token

````json
{
  "code": 500,
  "msg": "服务器繁忙",
  "data": null,
  "timestamp": 1722404886139
}
````

先处理一下这个响应内容，返回具体的报错信息，在资源模块引入一下系统模块api。

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/pom.xml`

````xml

<dependencies>
    <!-- 系统服务api模块 -->
    <dependency>
        <groupId>com.cmmplb</groupId>
        <artifactId>spring-cloud-oauth2-system-server-api</artifactId>
    </dependency>
</dependencies>
````

添加feign异常解码FeignClientErrorDecoder：

`com.cmmplb.oauth2.resource.server.feign.FeignClientErrorDecoder`

````java
package com.cmmplb.oauth2.resource.server.feign;

import com.alibaba.fastjson.JSONObject;
import com.cmmplb.oauth2.resource.server.handler.exception.BusinessException;
import com.cmmplb.oauth2.resource.server.result.HttpCodeEnum;
import com.cmmplb.oauth2.resource.server.result.Result;
import feign.Response;
import feign.Util;
import feign.codec.ErrorDecoder;
import lombok.extern.slf4j.Slf4j;

/**
 * @author penglibo
 * @date 2024-07-31 13:56:27
 * @since jdk 1.8
 * feign异常消息解码
 */

@Slf4j
public class FeignClientErrorDecoder implements ErrorDecoder {

    @Override
    public Exception decode(String methodKey, Response response) {
        log.error("methodKey:{},status:{}", methodKey, response.status());
        try {
            if (response.body() != null) {
                // 获取原始的返回内容
                String message = Util.toString(response.body().asReader(Util.UTF_8));
                // 将返回内容反序列化为Result，这里应根据自身项目作修改
                Result<?> result = JSONObject.parseObject(message, Result.class);
                throw new BusinessException(result.getCode(), result.getMsg());
            }
        } catch (Exception ignored) {
            // 部分异常响应
            if (response.status() == 401) {
                throw new BusinessException(HttpCodeEnum.UNAUTHORIZED);
            }
            if (response.status() == 403) {
                throw new BusinessException(HttpCodeEnum.FORBIDDEN);
            }
            if (response.status() == 404) {
                throw new BusinessException(HttpCodeEnum.NOT_FOUND);
            }
        }
        throw new BusinessException(response.status(), response.status(), methodKey);
    }
}
````

- 把配置类添加到spring.factories文件中：

````
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  // ...
  com.cmmplb.oauth2.resource.server.feign.FeignClientErrorDecoder
````

重启认证服务，再次调用，返回信息则会打印系统服务返回的未登录：

````json
{
  "code": 401,
  "msg": "未授权-未登录",
  "data": null,
  "timestamp": 1722405502228
}
````

之后添加拦截器，填充请求头信息

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/src/main/java/com/cmmplb/oauth2/resource/server/feign/FeignRequestInterceptor.java`

````java
package com.cmmplb.oauth2.resource.server.feign;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;

import javax.servlet.http.HttpServletRequest;

/**
 * @author penglibo
 * @date 2024-07-31 14:05:02
 * @since jdk 1.8
 * feign请求拦截，添加认证请求头
 */

public class FeignRequestInterceptor implements RequestInterceptor {

    @Autowired
    private HttpServletRequest request;

    @Override
    public void apply(RequestTemplate requestTemplate) {
        // 添加请求头Authorization
        requestTemplate.header(HttpHeaders.AUTHORIZATION, request.getHeader(HttpHeaders.AUTHORIZATION));
    }
}
````

- 把配置类添加到spring.factories文件中：

````
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  // ...
  com.cmmplb.oauth2.resource.server.feign.FeignRequestInterceptor
````

重启认证服务，调用测试，返回ok

----

看到有个这样的场景，https://blog.csdn.net/u014497669/article/details/116208231

有的接口只是内部feign不需要认证，调用并且不允许外部调用。

像之前的/user/info/{username}接口，是提供给认证服务加载用户信息调用的，现在用网关也可以不认证调用不安全。

- 在WithoutLogin注解添加一个内部服务aop权限拦截。

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/src/main/java/com/cmmplb/oauth2/resource/server/annotation/WithoutLogin.java`

````java

@Target(value = {ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface WithoutLogin {

    /**
     * 开启内部服务aop权限拦截
     */
    boolean value() default false;
}
````

添加一个常量SecurityConstant

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/src/main/java/com/cmmplb/oauth2/resource/server/constants/SecurityConstant.java`

````java
package com.cmmplb.oauth2.resource.server.constants;

/**
 * @author penglibo
 * @date 2024-07-31 15:42:14
 * @since jdk 1.8
 */
public interface SecurityConstant {

    /**
     * 内部服务调用请求头
     */
    String SOURCE = "Source";

    String INNER = "inner";
}
````

定义切面

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/src/main/java/com/cmmplb/oauth2/resource/server/aspect/SecurityInnerAspect.java`

````java
package com.cmmplb.oauth2.resource.server.aspect;

import com.cmmplb.oauth2.resource.server.annotation.WithoutLogin;
import com.cmmplb.oauth2.resource.server.constants.SecurityConstant;
import com.cmmplb.oauth2.resource.server.handler.exception.BusinessException;
import com.cmmplb.oauth2.resource.server.result.HttpCodeEnum;
import lombok.SneakyThrows;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.annotation.AnnotationUtils;

import javax.servlet.http.HttpServletRequest;

/**
 * @author penglibo
 * @date 2024-07-31 15:24:58
 * @since jdk 1.8
 * @within自定义注解标注的类下所有的方法都会进入切面的方法
 * @annotation自定义注解标注的方法会进入切面
 */

@Aspect
public class SecurityInnerAspect {

    @Autowired
    private HttpServletRequest request;

    @SneakyThrows
    @Around("@within(com.cmmplb.oauth2.resource.server.annotation.WithoutLogin)")
    public Object around(ProceedingJoinPoint joinPoint) {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        // 获取方法上的注解
        WithoutLogin withoutLogin = signature.getMethod().getAnnotation(WithoutLogin.class);
        if (null == withoutLogin) {
            // 获取类上的注解
            withoutLogin = AnnotationUtils.findAnnotation(joinPoint.getTarget().getClass(), WithoutLogin.class);
        }
        if (null != withoutLogin && withoutLogin.value() && !SecurityConstant.INNER.equals(request.getHeader(SecurityConstant.SOURCE))) {
            throw new BusinessException(HttpCodeEnum.FORBIDDEN.getCode(), HttpCodeEnum.FORBIDDEN.getCode(), "内部服务,外部禁止访问-未授权");
        }
        return joinPoint.proceed();
    }
}
````

- 把配置类添加到spring.factories文件中：

````
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  // ...
  com.cmmplb.oauth2.resource.server.aspect.SecurityInnerAspect
````

- 在PermissionController的admin添加WithoutLogin注解，并且开启aop拦截

`spring-cloud-oauth2/spring-cloud-oauth2-system-server/src/main/java/com/cmmplb/oauth2/system/server/controller/PermissionController.java`

````java
public class PermissionController {

    /**
     * 需要有管理员角色权限
     */
    @WithoutLogin(true)
    @PreAuthorize(value = "hasRole('admin')")
    @GetMapping("/admin")
    public String admin() {
        return "ok";
    }
}
````

- PermissionFeignClient添加请求头参数

`spring-cloud-oauth2/spring-cloud-oauth2-system-server-api/src/main/java/com/cmmplb/oauth2/system/server/api/client/PermissionFeignClient.java`

````java
public interface PermissionFeignClient {

    /**
     * 需要有管理员角色权限
     */
    @GetMapping("/admin")
    String admin(@RequestHeader("Source") String source);
}
````

- 实现类也需要添加

`spring-cloud-oauth2/spring-cloud-oauth2-system-server-api/src/main/java/com/cmmplb/oauth2/system/server/api/client/fallback/PermissionFeignClientFallBack.java`

````java
public class PermissionFeignClientFallBack implements FallbackFactory<PermissionFeignClient> {
    @Override
    public PermissionFeignClient create(Throwable cause) {
        return new PermissionFeignClient() {
            // ...
            @Override
            public String admin(String source) {
                return "error";
            }
        };
    }
}
````

之后在认证服务RemotePermissionController中调用

`com.cmmplb.oauth2.auth.server.controller.RemotePermissionController`

````java
public class RemotePermissionController {

    /**
     * 需要有管理员角色权限
     */
    @GetMapping("/admin")
    public String admin() {
        return permissionFeignClient.admin(SecurityConstant.INNER);
    }
}
````

重启系统服务和认证服务，当调用系统服务时，返回禁止访问。

````shell
curl --location 'http://localhost:10000/system/permission/admin' \
--header 'Authorization: bearer e11d806a-e963-4e2c-a415-18164981e169'
````

````json
{
  "code": 403,
  "msg": "内部服务,外部禁止访问-未授权",
  "data": null,
  "timestamp": 1722412739848
}
````

调用认证服务则返回ok

````shell
curl --location 'http://localhost:10000/auth/remote/permission/admin' \
--header 'Authorization: bearer e11d806a-e963-4e2c-a415-18164981e169'
````

- 测试完，这里顺便把UserController类上也添加@WithoutLogin(true)，标记用户名获取用户信息和手机号获取用户信息只允许内部服务访问。

`com.cmmplb.oauth2.system.server.controller.UserController`

````java

@WithoutLogin(true)
public class UserController {
    // ...
}
````

UserDetailsServiceImpl的restTemplate调用也添加请求头参数

`com.cmmplb.oauth2.resource.server.impl.UserDetailsServiceImpl`

````java
public class UserDetailsServiceImpl implements UserDetailsService {

    private Result<UserInfoVO> result(String url) {
        HttpHeaders headers = new HttpHeaders();
        headers.add(SecurityConstant.SOURCE, SecurityConstant.INNER);
        // ...
    }
}
````

测试访问info接口

````shell
curl --location 'http://localhost:10000/system/user/info/admin'
````

````json
{
  "code": 403,
  "msg": "内部服务,外部禁止访问-未授权",
  "data": null,
  "timestamp": 1722415420946
}
````

但手动添加请求头Source的话能请求成功

````
curl --location 'http://localhost:10000/system/user/info/admin' \
--header 'Source: inner' \
````

````json
{
  "code": 200,
  "msg": "操作成功",
  "data": {
    "user": {
      "id": 1,
      "username": "admin",
      "password": "e10adc3949ba59abbe56e057f20f883e",
      "mobile": "18888888888"
    },
    "roles": [
      "admin"
    ],
    "permissions": [
      "read"
    ]
  },
  "timestamp": 1722415464997
}
````

这里在网关移除服务内部调用使用的Source请求头信息

`spring-cloud-oauth2/spring-cloud-oauth2-gateway-server/src/main/java/com/cmmplb/oauth2/gateway/server/filters/RequestGlobalFilter.java`

````java
package com.cmmplb.oauth2.gateway.server.filters;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.cloud.gateway.filter.NettyWriteResponseFilter;
import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

/**
 * @author penglibo
 * @date 2024-07-31 16:46:33
 * @since jdk 1.8
 * 移除内部服务调用使用的请求头
 */

@Component
public class RequestGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest().mutate()
                .headers(httpHeaders -> httpHeaders.remove("Source")).build();
        return chain.filter(exchange.mutate().request(request.mutate().build()).build());
    }

    @Override
    public int getOrder() {
        return NettyWriteResponseFilter.WRITE_RESPONSE_FILTER_ORDER - 1;
    }
}
````

再次请求

````shell
curl --location 'http://localhost:10000/system/user/info/admin' \
--header 'Source: inner' \
````

````json
{
  "code": 403,
  "msg": "内部服务,外部禁止访问-未授权",
  "data": null,
  "timestamp": 1722415725276
}
````

----

## JWT令牌密钥配置

这里顺便把之前相关的配置都改了。

### oauth2配置

前面的一些基于内存和数据库的配置，测试的时候要修改很多地方，把他整理成由配置文件定义，在实际项目中这些配置都不会轻易变动的，这里只是为了学习，改成配置文件定义方便切换测试。

其中有这几个类型配置：令牌存储类型、用户信息类型、客户端信息类型、授权码类型、授权信息类型

- 添加配置实体Oauth2ConfigProperties

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/src/main/java/com/cmmplb/oauth2/resource/server/configuration/properties/Oauth2ConfigProperties.java`

````java
package com.cmmplb.oauth2.resource.server.configuration.properties;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.security.oauth2.provider.client.BaseClientDetails;

import java.util.ArrayList;
import java.util.List;

/**
 * @author penglibo
 * @date 2024-07-31 16:52:09
 * @since jdk 1.8
 * oauth2相关存储配置
 */

@Data
@ConfigurationProperties(prefix = "security.oauth2")
public class Oauth2ConfigProperties {

    /**
     * 令牌存储类型
     */
    private TokenStoreType tokenStoreType = TokenStoreType.IN_MEMORY;

    /**
     * Jwt密钥配置
     */
    private JwtKey jwtKey = new JwtKey();

    /**
     * 是否使用DefaultTokenServices
     */
    private boolean defaultTokenServices = false;

    /**
     * 用户信息类型
     */
    private UserDetailsServiceType userDetailsServiceType = UserDetailsServiceType.IN_MEMORY;

    /**
     * 客户端信息类型
     */
    private ClientDetailsServiceType clientDetailsServiceType = ClientDetailsServiceType.IN_MEMORY;

    /**
     * 授权码类型
     */
    private AuthorizationCodeServicesType authorizationCodeServicesType = AuthorizationCodeServicesType.IN_MEMORY;

    /**
     * 授权信息类型
     */
    private ApprovalStoreType approvalStoreType = ApprovalStoreType.IN_MEMORY;

    /**
     * 内存客户端配置
     */
    private List<BaseClientDetails> clients = new ArrayList<>();

    /**
     * 内存用户配置
     */
    private List<BaseUserDetails> users = new ArrayList<>();

    /**
     * Jwt密钥配置
     */
    @Data
    public static class JwtKey {

        /**
         * 是否为授权服务
         */
        private boolean authorized = false;

        /**
         * 认证服务配置
         */
        private Authorization authorization;

        /**
         * 客户端配置
         */
        private Client client;

        @Data
        public static class Authorization {

            /**
             * 是否使用对称加密方式
             */
            private boolean symmetric = true;

            /**
             * 对称加密签名密钥
             */
            private String signingKey;

            /**
             * 非对称加密密钥路径
             */
            private String keyPath;

            /**
             * 非对称加密密钥密码
             */
            private String pass;

            /**
             * 非对称加密密钥别名
             */
            private String alias;
        }

        @Data
        public static class Client {

            /**
             * 是否使用对称加密方式
             */
            private boolean symmetric = true;

            /**
             * 解密使用的对称加密签名密钥
             */
            private String signingKey;

            /**
             * 公钥路径
             */
            private String publicKeyFilePath;
        }
    }

    /**
     * 令牌存储类型
     */
    public enum TokenStoreType {

        IN_MEMORY,

        JDBC,

        JWT,

        REDIS
    }

    /**
     * 客户端信息类型
     */
    public enum ClientDetailsServiceType {

        IN_MEMORY,

        JDBC,

        /**
         * 经过jdbc查询之后缓存到redis
         */
        REDIS
    }

    /**
     * 授权码类型
     */
    public enum AuthorizationCodeServicesType {

        IN_MEMORY,

        JDBC,

        REDIS
    }

    /**
     * 授权信息类型
     */
    public enum ApprovalStoreType {

        IN_MEMORY,

        JDBC,

        Token
    }

    /**
     * 用户信息类型
     */
    public enum UserDetailsServiceType {

        IN_MEMORY,

        JDBC
    }

    /**
     * 内存用户配置
     */
    @Data
    public static class BaseUserDetails {

        /**
         * 用户名
         */
        private String username;

        /**
         * 密码
         */
        private String password;

        /**
         * 角色
         */
        private List<String> roles;

        /**
         * 权限
         */
        private List<String> authorities;

        /**
         * 账号是否过期
         */
        private boolean accountNonExpired = false;

        /**
         * 账号是否锁定
         */
        private boolean accountNonLock = false;

        /**
         * 凭证是否过期
         */
        private boolean credentialsNonExpired = false;

        /**
         * 账号是否禁用
         */
        private boolean disable = false;
    }
}
````

认证服务模块添加application-security_oauth2.yml配置文件

`spring-cloud-oauth2/spring-cloud-oauth2-auth-server/src/main/resources/config/application-security_oauth2.yml`

````yaml
security:
  oauth2:
    # 令牌存储类型: IN_MEMORY, JDBC, JWT, REDIS
    tokenStoreType: JWT
    # Jwt密钥配置
    jwt-key:
      # 是否为授权服务
      authorized: true
      # 服务端密钥配置
      authorization:
        # 是否对称加密, 默认为true
        symmetric: false
        # 对称加密签名密钥
        signingKey: cmmplb
        # 非对称加密密钥路径
        key-path: key/oauth2.jks
        # 非对称加密密钥密码
        pass: oauth2
        # 非对称加密密钥别名
        alias: oauth2
    # 授权码存储类型: IN_MEMORY, JDBC, REDIS
    authorizationCodeServicesType: REDIS
    # 用户信息类型: IN_MEMORY, JDBC
    userDetailsServiceType: JDBC
    # 客户端信息类型: IN_MEMORY, JDBC, REDIS
    clientDetailsServiceType: REDIS
    # 用户信息配置, 如果未定义数据库配置, 则使用此配置, 基于内存配置
    users:
      - # 用户名, 模拟管理员用户
        username: admin
        # 密码
        password: 123456
        # 角色
        roles:
          - admin
        # 权限
        authorities:
          - read
          - write
      - # 用户名, 模拟普通用户
        username: user
        password: 123456
        roles:
          - user
        authorities:
          - read
    # 客户端信息配置, 如果未定义数据库配置, 则使用此配置, 基于内存配置
    clients:
      - # 客户端id
        client-id: web
        # 客户端密钥, 注意数据库存储的时候需要加密
        client-secret: 123456
        # 是否自动授权, 为false登录后会跳转到授权页面
        auto-approve-scopes:
          - false
        # 授权范围
        scope:
          - username
          - phone
          - age
        # 令牌有效期, 默认为12小时
        access-token-validity-seconds: 43200
        # 刷新令牌有效期, 默认为30天
        refresh-token-validity-seconds: 2592000
        # 登录成功回调地址, 这里如果配置了多个, 则请求地址需要携带redirect_uri参数, 并且值是配置的其中一个, 如果只配置一个, 则可以不带redirect_uri参数
        registered-redirect-uri:
          - http://localhost:10000/auth/actuator/health
          - http://localhost:20000/actuator/health
          - http://localhost:18080/auth
        # 授权类型
        authorized-grant-types:
          - client_credentials
          - password
          - implicit
          - authorization_code
          - refresh_token
      - # 提供给单点服务客户端信息
        client-id: sso-one
        client-secret: 123456
        auto-approve-scopes:
          - false
        # 授权范围
        scope:
          - username
          - phone
          - age
        registered-redirect-uri:
          - http://localhost:40000/login
          - http://127.0.0.1:40000/login
        authorized-grant-types:
          - authorization_code
          - refresh_token
      - # 提供给单点服务客户端信息
        client-id: sso-two
        client-secret: 123456
        auto-approve-scopes:
          - false
        # 授权范围
        scope:
          - username
          - phone
          - age
        registered-redirect-uri:
          - http://localhost:50000/login
          - http://127.0.0.1:50000/login
        authorized-grant-types:
          - authorization_code
          - refresh_token
      - # 提供给系统服务校验token的客户端信息
        client-id: system-server
        client-secret: 123456
        auto-approve-scopes:
          - false
        # 授权范围
        scope:
          - username
          - phone
          - age
        authorized-grant-types:
          - client_credentials
````

- bootstrap.yml引用该配置：

````yaml
spring:
  profiles:
    # 引用配置文件
    include:
      # ...
      - security_oauth2
````

- 添加授权码和客户端的redis实现：

授权码redis存储模式：

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/src/main/java/com/cmmplb/oauth2/resource/server/impl/RedisAuthorizationCodeServicesImpl.java`

````java
package com.cmmplb.oauth2.resource.server.impl;

import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.connection.RedisConnection;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.code.RandomValueAuthorizationCodeServices;
import org.springframework.security.oauth2.provider.token.store.redis.JdkSerializationStrategy;
import org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore;
import org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStoreSerializationStrategy;
import org.springframework.util.ClassUtils;
import org.springframework.util.ReflectionUtils;

import java.lang.reflect.Method;

/**
 * @author penglibo
 * @date 2024-08-01 11:12:28
 * @since jdk 1.8
 * 授权码redis存储模式，参照内存存储模式，RedisTokenStore中redis操作
 * {@link org.springframework.security.oauth2.provider.code.InMemoryAuthorizationCodeServices}
 * {@link org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore}
 */

@Slf4j
public class RedisAuthorizationCodeServicesImpl extends RandomValueAuthorizationCodeServices {

    private final RedisConnectionFactory connectionFactory;
    private final RedisTokenStoreSerializationStrategy serializationStrategy = new JdkSerializationStrategy();
    private static final boolean SPRING_DATA_REDIS_2_0 = ClassUtils.isPresent(
            "org.springframework.data.redis.connection.RedisStandaloneConfiguration",
            RedisTokenStore.class.getClassLoader());
    private Method redisConnectionSet20;

    /**
     * 授权码CODE缓存前缀
     */
    private static final String AUTHORIZATION_CODE_CACHE_PREFIX = "oauth:authorization:code:";

    /**
     * 授权码code缓存时效-5分钟
     */
    private static final long AUTHORIZATION_CODE_CACHE_TIME = 60 * 5;

    public RedisAuthorizationCodeServicesImpl(RedisConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
        if (SPRING_DATA_REDIS_2_0) {
            this.loadRedisConnectionMethods20();
        }
    }

    private void loadRedisConnectionMethods20() {
        this.redisConnectionSet20 = ReflectionUtils.findMethod(
                RedisConnection.class, "set", byte[].class, byte[].class);
    }

    @Override
    protected void store(String code, OAuth2Authentication authentication) {
        log.debug("store authorization code :{}", code);
        byte[] serializedAuth = serialize(authentication);
        byte[] serializedKey = serializeKey(get(code));
        try (RedisConnection conn = getConnection()) {
            conn.openPipeline();
            if (SPRING_DATA_REDIS_2_0) {
                try {
                    this.redisConnectionSet20.invoke(conn, serializedKey, serializedAuth);
                } catch (Exception ex) {
                    throw new RuntimeException(ex);
                }
            } else {
                conn.set(serializedKey, serializedAuth);
                conn.expire(serializedKey, AUTHORIZATION_CODE_CACHE_TIME);
            }
            conn.closePipeline();
        }
    }

    @Override
    protected OAuth2Authentication remove(String code) {
        log.debug("remove authorization code :{}", code);
        byte[] serializedKey = serializeKey(get(code));
        try (RedisConnection conn = getConnection()) {
            byte[] bytes = conn.get(serializedKey);
            OAuth2Authentication oAuth2Authentication = deserializeAuthentication(bytes);
            if (null != oAuth2Authentication) {
                conn.del(serializeKey(get(code)));
                return oAuth2Authentication;
            }
        }
        return null;
    }

    private RedisConnection getConnection() {
        return connectionFactory.getConnection();
    }

    private byte[] serializeKey(String object) {
        return serialize(object);
    }

    private byte[] serialize(String string) {
        return serializationStrategy.serialize(string);
    }

    private byte[] serialize(Object object) {
        return serializationStrategy.serialize(object);
    }

    private OAuth2Authentication deserializeAuthentication(byte[] bytes) {
        return serializationStrategy.deserialize(bytes, OAuth2Authentication.class);
    }

    private String get(String code) {
        return AUTHORIZATION_CODE_CACHE_PREFIX + code;
    }
}
````

客户端的redis实现，会先查询数据库，之后进行缓存：

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/src/main/java/com/cmmplb/oauth2/resource/server/impl/RedisClientDetailsServiceImpl.java`

````java
package com.cmmplb.oauth2.resource.server.impl;

import org.springframework.cache.annotation.Cacheable;
import org.springframework.security.oauth2.provider.ClientDetails;
import org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;

import javax.sql.DataSource;

/**
 * @author penglibo
 * @date 2024-08-01 11:11:06
 * @since jdk 1.8
 */

public class RedisClientDetailsServiceImpl extends JdbcClientDetailsService {

    /**
     * oauth 客户端信息
     */
    public static final String CLIENT_DETAILS_KEY = "oauth:client:details";

    public RedisClientDetailsServiceImpl(DataSource dataSource) {
        super(dataSource);
    }

    @Override
    @Cacheable(value = CLIENT_DETAILS_KEY, key = "#clientId", unless = "#result == null")
    public ClientDetails loadClientByClientId(String clientId) {
        return super.loadClientByClientId(clientId);
    }
}
````

- 读取配置文件，调整AuthorizationServerConfiguration和WebSecurityConfiguration中的配置：

`com.cmmplb.oauth2.auth.server.configuration.AuthorizationServerConfiguration`

````java
package com.cmmplb.oauth2.auth.server.configuration;

import com.cmmplb.oauth2.resource.server.configuration.properties.Oauth2ConfigProperties;
import com.cmmplb.oauth2.resource.server.handler.GlobalWebResponseExceptionTranslator;
import com.cmmplb.oauth2.resource.server.impl.RedisAuthorizationCodeServicesImpl;
import com.cmmplb.oauth2.resource.server.impl.RedisClientDetailsServiceImpl;
import com.cmmplb.oauth2.resource.server.mobile.MobileTokenGranter;
import com.cmmplb.oauth2.resource.server.service.UserDetailsService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.config.annotation.builders.ClientDetailsServiceBuilder;
import org.springframework.security.oauth2.config.annotation.builders.InMemoryClientDetailsServiceBuilder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.ClientDetailsService;
import org.springframework.security.oauth2.provider.CompositeTokenGranter;
import org.springframework.security.oauth2.provider.TokenGranter;
import org.springframework.security.oauth2.provider.approval.ApprovalStore;
import org.springframework.security.oauth2.provider.approval.InMemoryApprovalStore;
import org.springframework.security.oauth2.provider.approval.JdbcApprovalStore;
import org.springframework.security.oauth2.provider.approval.TokenApprovalStore;
import org.springframework.security.oauth2.provider.client.BaseClientDetails;
import org.springframework.security.oauth2.provider.code.AuthorizationCodeServices;
import org.springframework.security.oauth2.provider.code.InMemoryAuthorizationCodeServices;
import org.springframework.security.oauth2.provider.code.JdbcAuthorizationCodeServices;
import org.springframework.security.oauth2.provider.token.*;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.util.CollectionUtils;

import javax.sql.DataSource;
import java.util.ArrayList;
import java.util.Collections;

/**
 * @author penglibo
 * @date 2024-07-04 10:28:32
 * @since jdk 1.8
 * oauth2授权服务器配置
 */

@Slf4j
@Configuration
@EnableAuthorizationServer
@EnableConfigurationProperties(Oauth2ConfigProperties.class)
public class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private TokenStore tokenStore;

    @Autowired
    private DataSource dataSource;

    @Autowired
    private TokenEnhancer tokenEnhancer;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired(required = false)
    private UserDetailsService userDetailsService;

    @Autowired
    private AccessTokenConverter accessTokenConverter;

    @Autowired
    private ClientDetailsService clientDetailsService;

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private Oauth2ConfigProperties oauth2ConfigProperties;

    @Autowired
    private RedisConnectionFactory redisConnectionFactory;

    @Autowired(required = false)
    private InMemoryUserDetailsManager inMemoryUserDetailsManager;

    @Autowired
    private GlobalWebResponseExceptionTranslator globalWebResponseExceptionTranslator;

    /**
     * 配置授权服务器端点的非安全功能，如令牌存储、令牌自定义、用户批准和授权类型。
     * 默认情况下你不需要做任何事情，除非你需要密码授权，在这种情况下你需要提供一个 {@link AuthenticationManager}。 *
     * @param endpoints 端点配置器
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
        endpoints
                // 重复使用reuseRefreshToken
                .reuseRefreshTokens(false)
                // 用户信息服务
                .userDetailsService(userDetailsService())
                // 配置认证管理器
                .authenticationManager(authenticationManager)
                // 配置grant_type模式
                .tokenGranter(tokenGranter(endpoints))
                // 拓展token信息
                .tokenEnhancer(tokenEnhancer)
                // 配置token存储
                .tokenStore(tokenStore)
                // 认证服务器的token服务
                .tokenServices(tokenServices())
                // 配置token转换器
                .accessTokenConverter(accessTokenConverter)
                // 配置授权存储
                .approvalStore(approvalStore())
                // 配置授权码存储
                .authorizationCodeServices(authorizationCodeServices())
                // 自定义异常处理
                .exceptionTranslator(globalWebResponseExceptionTranslator)
                // 替换默认的授权页面地址，参数1是默认地址，参数2是自定义地址
                .pathMapping("/oauth/confirm_access", "/oauth/confirm/access")
                // 替换默认的错误页面地址
                .pathMapping("/oauth/error", "/oauth/error")
        ;
    }

    /**
     * 配置令牌端点(Token Endpoint)的安全约束
     */
    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) {
        security
                // 允许客户端表单验证，默认false
                .allowFormAuthenticationForClients()
                // 允许校验token请求，默认denyAll()
                .checkTokenAccess("permitAll()");
    }

    /**
     * 配置客户端详情
     * @param clients 客户端配置器
     * @throws Exception e
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        if (oauth2ConfigProperties.getClientDetailsServiceType().equals(Oauth2ConfigProperties.ClientDetailsServiceType.JDBC)) {
            clients.jdbc(dataSource);
        } else if (oauth2ConfigProperties.getClientDetailsServiceType().equals(Oauth2ConfigProperties.ClientDetailsServiceType.REDIS)) {
            clients.withClientDetails(new RedisClientDetailsServiceImpl(dataSource));
        } else {
            InMemoryClientDetailsServiceBuilder serviceBuilder = clients.inMemory();
            for (BaseClientDetails client : oauth2ConfigProperties.getClients()) {
                ClientDetailsServiceBuilder<InMemoryClientDetailsServiceBuilder>.ClientBuilder clientBuilder =
                        serviceBuilder.withClient(client.getClientId());
                clientBuilder.secret(passwordEncoder.encode(client.getClientSecret()));
                if (!CollectionUtils.isEmpty(client.getAutoApproveScopes())) {
                    clientBuilder.autoApprove(client.getAutoApproveScopes().toArray(new String[0]));
                }
                if (!CollectionUtils.isEmpty(client.getScope())) {
                    clientBuilder.scopes(client.getScope().toArray(new String[0]));
                }
                if (!CollectionUtils.isEmpty(client.getRegisteredRedirectUri())) {
                    clientBuilder.redirectUris(client.getRegisteredRedirectUri().toArray(new String[0]));
                }
                if (!CollectionUtils.isEmpty(client.getAuthorizedGrantTypes())) {
                    clientBuilder.authorizedGrantTypes(client.getAuthorizedGrantTypes().toArray(new String[0]));
                }
                if (null != client.getAccessTokenValiditySeconds()) {
                    clientBuilder.accessTokenValiditySeconds(client.getAccessTokenValiditySeconds());
                }
                if (null != client.getRefreshTokenValiditySeconds()) {
                    clientBuilder.refreshTokenValiditySeconds(client.getRefreshTokenValiditySeconds());
                }
            }
        }
    }

    /**
     * 认证服务器的token服务，使用@Primary覆盖ResourceServerTokenServices
     * 不定义这个bean的话，当携带token请求认证服务，会经过ResourceServerTokenServices调用checkToken或者userInfo方法重复调用，
     * 本身就是auth获取自身的资源，不需要再调用checkToken接口验证了，直接使用DefaultTokenServices通过tokenStore验签
     */
    @Bean
    @Primary
    public AuthorizationServerTokenServices tokenServices() {
        DefaultTokenServices tokenServices = new DefaultTokenServices();
        tokenServices.setTokenStore(tokenStore);
        tokenServices.setSupportRefreshToken(true);
        tokenServices.setReuseRefreshToken(true);
        tokenServices.setTokenEnhancer(tokenEnhancer);
        tokenServices.setClientDetailsService(clientDetailsService);
        return tokenServices;
    }

    /**
     * 创建grant_type列表，如果不配置则默认使用密码模式、简化模式、授权码模式、客户端模式以及刷新token模式
     * {@link AuthorizationServerEndpointsConfigurer#getDefaultTokenGranters()}
     * 如果配置了只使用配置中，默认配置失效
     * @param endpoints 端点配置器
     * @return TokenGranter
     */
    @SuppressWarnings("JavadocReference")
    private TokenGranter tokenGranter(AuthorizationServerEndpointsConfigurer endpoints) {
        // 在原有配置下添加手机号验证码模式
        TokenGranter tokenGranter = endpoints.getTokenGranter();
        ArrayList<TokenGranter> tokenGranters = new ArrayList<>(Collections.singletonList(tokenGranter));
        // 添加一个自定义手机号验证码模式
        tokenGranters.add(new MobileTokenGranter(endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory(), authenticationManager));
        return new CompositeTokenGranter(tokenGranters);
    }

    /**
     * 基于数据库获取授权信息
     */
    public ApprovalStore approvalStore() {
        ApprovalStore approvalStore;
        if (oauth2ConfigProperties.getApprovalStoreType().equals(Oauth2ConfigProperties.ApprovalStoreType.JDBC)) {
            approvalStore = new JdbcApprovalStore(dataSource);
        } else if (oauth2ConfigProperties.getApprovalStoreType().equals(Oauth2ConfigProperties.ApprovalStoreType.Token)) {
            approvalStore = new TokenApprovalStore();
        } else {
            approvalStore = new InMemoryApprovalStore();
        }
        return approvalStore;
    }

    /**
     * 授权码信息
     */
    public AuthorizationCodeServices authorizationCodeServices() {
        AuthorizationCodeServices authorizationCodeServices;
        if (oauth2ConfigProperties.getAuthorizationCodeServicesType().equals(Oauth2ConfigProperties.AuthorizationCodeServicesType.JDBC)) {
            authorizationCodeServices = new JdbcAuthorizationCodeServices(dataSource);
        } else if (oauth2ConfigProperties.getAuthorizationCodeServicesType().equals(Oauth2ConfigProperties.AuthorizationCodeServicesType.REDIS)) {
            authorizationCodeServices = new RedisAuthorizationCodeServicesImpl(redisConnectionFactory);
        } else {
            authorizationCodeServices = new InMemoryAuthorizationCodeServices();
        }
        return authorizationCodeServices;
    }

    /**
     * 用户信息
     */
    public org.springframework.security.core.userdetails.UserDetailsService userDetailsService() {
        if (oauth2ConfigProperties.getUserDetailsServiceType().equals(Oauth2ConfigProperties.UserDetailsServiceType.JDBC)) {
            return userDetailsService;
        } else {
            return inMemoryUserDetailsManager;
        }
    }
}
````

- 生成密钥文件存放在认证服务resources/key目录下，生成规则在末尾

- auth模块xml添加resource识别密钥文件

`spring-cloud-oauth2/spring-cloud-oauth2-auth-server/pom.xml`

````xml

<build>
    <resources>
        <resource>
            <directory>src/main/resources</directory>
            <filtering>true</filtering>
            <excludes>
                <exclude>**/*.jks</exclude>
            </excludes>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
            <filtering>false</filtering>
            <includes>
                <include>**/*.jks</include>
            </includes>
        </resource>
    </resources>
</build>
````

`com.cmmplb.oauth2.auth.server.configuration.WebSecurityConfiguration`

````java
package com.cmmplb.oauth2.auth.server.configuration;

import com.cmmplb.oauth2.resource.server.configuration.properties.Oauth2ConfigProperties;
import com.cmmplb.oauth2.resource.server.mobile.MobileAuthenticationProvider;
import com.cmmplb.oauth2.resource.server.service.UserDetailsService;
import com.cmmplb.oauth2.resource.server.utils.MD5Util;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer;
import org.springframework.security.config.annotation.authentication.configurers.provisioning.UserDetailsManagerConfigurer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.util.CollectionUtils;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.List;

/**
 * @author penglibo
 * @date 2024-07-04 10:05:16
 * @since jdk 1.8
 * Security安全配置
 */

@Slf4j
@Order(1)
@Configuration
@EnableWebSecurity
@EnableConfigurationProperties(Oauth2ConfigProperties.class)
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter implements WebMvcConfigurer {

    @Autowired
    private Oauth2ConfigProperties oauth2ConfigProperties;

    @Autowired(required = false)
    private UserDetailsService userDetailsService;

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http
                // 受保护的资源路径，其他路径则交给资源服务器处理
                .requestMatchers().antMatchers("/oauth/**", "/login/**", "/logout/**")
                .and()
                // 注册手机号验证码登录提供器
                .authenticationProvider(mobileAuthenticationProvider())
                // 表单登录
                .formLogin().permitAll()
                // 登录页面路径，默认/login，由于默认的登录页引用了bootstrapcdn，网络不通情况导致页面一直加载，直到bootstrap.min.css超时才响应，
                // 这里复制默认的页面，去掉bootstrap的引用，单独下载文件，实现登录功能
                .loginPage("/oauth/login")
                // 提交登录的接口路径，默认/login，如果通过网关的话，需要网关添加转发，也可以在路径前添加服务名/auth/login，不过后者单独请求认证服务的话就会404
                .loginProcessingUrl("/login")
                .and()
                .authorizeRequests()
                // 放行登录页面引用的css
                .antMatchers("/css/**").permitAll()
                .anyRequest().authenticated()
                .and()
                // 关闭跨域保护
                .csrf().disable();
    }

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // 基于thymeleaf映射登录页面
        registry.addViewController("/oauth/login").setViewName("login-page");
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(mobileAuthenticationProvider());
        if (oauth2ConfigProperties.getUserDetailsServiceType().equals(Oauth2ConfigProperties.UserDetailsServiceType.JDBC)) {
            auth.userDetailsService(userDetailsService);
        } else {
            List<Oauth2ConfigProperties.BaseUserDetails> users = oauth2ConfigProperties.getUsers();
            // 基于内存中的身份验证
            InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> configurer = auth.inMemoryAuthentication()
                    .passwordEncoder(passwordEncoder());
            for (Oauth2ConfigProperties.BaseUserDetails user : users) {
                UserDetailsManagerConfigurer<AuthenticationManagerBuilder, InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder>>.UserDetailsBuilder userDetailsBuilder = configurer
                        .withUser(user.getUsername());
                userDetailsBuilder.password(passwordEncoder().encode(user.getPassword()))
                        .accountExpired(user.isAccountNonExpired()).accountLocked(user.isAccountNonLock())
                        .credentialsExpired(user.isCredentialsNonExpired()).disabled(user.isDisable());
                if (!CollectionUtils.isEmpty(user.getRoles())) {
                    userDetailsBuilder.roles(user.getRoles().toArray(new String[0]));
                }
                if (!CollectionUtils.isEmpty(user.getAuthorities())) {
                    userDetailsBuilder.authorities(user.getAuthorities().toArray(new String[0]));
                }
            }
        }
    }

    /**
     * 使用数据库加载用户，注释掉userDetailsServiceBean，不然注入UserDetailsService会显示有多个实现的bean
     * 也可以不移除，上面注入的private UserDetailsService userDetailsService; 就需要改成具体实现类：private UserDetailsServiceImpl userDetailsServiceImpl
     * 或者自定义UserDetailsService
     */
    @Bean
    @Override
    public org.springframework.security.core.userdetails.UserDetailsService userDetailsServiceBean() throws Exception {
        return super.userDetailsServiceBean();
    }

    @Bean
    public MobileAuthenticationProvider mobileAuthenticationProvider() {
        MobileAuthenticationProvider mobileAuthenticationProvider = new MobileAuthenticationProvider();
        mobileAuthenticationProvider.setUserDetailsService(userDetailsService);
        return mobileAuthenticationProvider;
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        // 自定义MD5加密方式
        return new PasswordEncoder() {

            /**
             * MD5加密
             */
            @Override
            public String encode(CharSequence rawPassword) {
                log.info("加密：{}", rawPassword);
                return MD5Util.encode(String.valueOf(rawPassword));
            }

            /**
             * 匹配密码，rawPassword为输入的，encodedPassword数据库查出来的
             */
            @Override
            public boolean matches(CharSequence rawPassword, String encodedPassword) {
                log.info("解密：{},{}", rawPassword, encodedPassword);
                return encodedPassword.equals(MD5Util.encode(String.valueOf(rawPassword)));
            }
        };
        // return new BCryptPasswordEncoder(10);
    }
}
````

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/src/main/java/com/cmmplb/oauth2/resource/server/configuration/ResourceAutoConfiguration.java`

````java
package com.cmmplb.oauth2.resource.server.configuration;

import com.cmmplb.oauth2.resource.server.configuration.properties.Oauth2ConfigProperties;
import com.cmmplb.oauth2.resource.server.configuration.properties.RestTemplateProperties;
import com.cmmplb.oauth2.resource.server.handler.AccessDeniedHandler;
import com.cmmplb.oauth2.resource.server.handler.exception.BusinessException;
import com.cmmplb.oauth2.resource.server.impl.TokenEnhancerImpl;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.IOUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.security.oauth2.resource.ResourceServerProperties;
import org.springframework.boot.autoconfigure.security.oauth2.resource.ResourceServerTokenServicesConfiguration;
import org.springframework.boot.autoconfigure.security.oauth2.resource.UserInfoTokenServices;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.security.config.annotation.authentication.configuration.EnableGlobalAuthentication;
import org.springframework.security.oauth2.client.OAuth2RestTemplate;
import org.springframework.security.oauth2.client.resource.BaseOAuth2ProtectedResourceDetails;
import org.springframework.security.oauth2.client.token.JdbcClientTokenServices;
import org.springframework.security.oauth2.provider.expression.OAuth2MethodSecurityExpressionHandler;
import org.springframework.security.oauth2.provider.token.*;
import org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;
import org.springframework.security.oauth2.provider.token.store.JdbcTokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
import org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore;
import org.springframework.security.rsa.crypto.KeyStoreKeyFactory;
import org.springframework.web.client.DefaultResponseErrorHandler;
import org.springframework.web.client.RestTemplate;

import javax.sql.DataSource;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.SocketAddress;
import java.util.Base64;
import java.util.Map;
import java.util.Objects;

/**
 * @author penglibo
 * @date 2024-07-16 17:17:52
 * @since jdk 1.8
 */

@Slf4j
@SuppressWarnings("JavadocReference")
@EnableGlobalAuthentication
@EnableConfigurationProperties({RestTemplateProperties.class, Oauth2ConfigProperties.class})
public class ResourceAutoConfiguration {

    @Autowired
    private DataSource dataSource;

    @Autowired
    private Oauth2ConfigProperties oauth2ConfigProperties;

    @Autowired
    private RestTemplateProperties restTemplateProperties;

    @Autowired
    private RedisConnectionFactory redisConnectionFactory;

    @Autowired
    private ResourceServerProperties resourceServerProperties;

    /**
     * 远程令牌服务
     */
    @Bean
    public ResourceServerTokenServices resourceServerTokenServices() {
        // 默认令牌服务，可以在验证JWT密钥相关功能打开测试
        if (oauth2ConfigProperties.isDefaultTokenServices()) {
            DefaultTokenServices defaultTokenServices = new DefaultTokenServices();
            defaultTokenServices.setTokenStore(tokenStore());
            defaultTokenServices.setSupportRefreshToken(true);
            defaultTokenServices.setReuseRefreshToken(true);
            defaultTokenServices.setTokenEnhancer(tokenEnhancer());
            return defaultTokenServices;
        }
        // 使用代码配置，会覆盖配置文件中实例，org.springframework.boot.autoconfigure.security.oauth2.resource.ResourceServerTokenServicesConfiguration.RemoteTokenServicesConfiguration.UserInfoTokenServicesConfiguration.userInfoTokenServices
        if (resourceServerProperties.isPreferTokenInfo()) {
            RemoteTokenServices remoteTokenServices = new RemoteTokenServices();
            remoteTokenServices.setRestTemplate(restTemplate());
            // 通过org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration
            // 从OAuth2ClientProperties把clientId和clientSecret设置到ResourceServerProperties
            remoteTokenServices.setClientId(resourceServerProperties.getClientId());
            remoteTokenServices.setClientSecret(resourceServerProperties.getClientSecret());
            remoteTokenServices.setCheckTokenEndpointUrl(resourceServerProperties.getTokenInfoUri());
            return remoteTokenServices;
        } else {
            UserInfoTokenServices userInfoTokenServices = new UserInfoTokenServices(
                    resourceServerProperties.getUserInfoUri(), resourceServerProperties.getClientId());
            userInfoTokenServices.setRestTemplate(oAuth2RestTemplate());
            return userInfoTokenServices;
        }
    }

    /**
     * 服务调用
     */
    @Bean
    @LoadBalanced
    public OAuth2RestTemplate oAuth2RestTemplate() {
        BaseOAuth2ProtectedResourceDetails resource = new BaseOAuth2ProtectedResourceDetails();
        resource.setClientId(resourceServerProperties.getClientId());
        return new OAuth2RestTemplate(resource);
    }

    /**
     * 服务调用
     */
    @Bean
    @Primary
    @LoadBalanced
    public RestTemplate restTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        restTemplate.setErrorHandler(new DefaultResponseErrorHandler());
        restTemplate.setRequestFactory(getSimpleClientFactory());
        return restTemplate;
    }

    /**
     * 令牌存储
     */
    @Bean
    @Primary
    public TokenStore tokenStore() {
        TokenStore tokenStore;
        if (oauth2ConfigProperties.getTokenStoreType().equals(Oauth2ConfigProperties.TokenStoreType.JDBC)) {
            tokenStore = new JdbcTokenStore(dataSource);
        } else if (oauth2ConfigProperties.getTokenStoreType().equals(Oauth2ConfigProperties.TokenStoreType.REDIS)) {
            tokenStore = new RedisTokenStore(redisConnectionFactory);
        } else if (oauth2ConfigProperties.getTokenStoreType().equals(Oauth2ConfigProperties.TokenStoreType.JWT)) {
            tokenStore = new JwtTokenStore(jwtAccessTokenConverter());
        } else {
            tokenStore = new InMemoryTokenStore();
        }
        return tokenStore;
    }

    /**
     * 拓展token信息
     */
    @Bean
    public TokenEnhancer tokenEnhancer() {
        if (oauth2ConfigProperties.getTokenStoreType().equals(Oauth2ConfigProperties.TokenStoreType.JWT)) {
            return jwtAccessTokenConverter();
        } else {
            return new TokenEnhancerImpl();
        }
    }

    /**
     * 令牌转换器
     */
    @Bean
    public AccessTokenConverter accessTokenConverter() {
        AccessTokenConverter accessTokenConverter;
        if (oauth2ConfigProperties.getTokenStoreType().equals(Oauth2ConfigProperties.TokenStoreType.JWT)) {
            accessTokenConverter = jwtAccessTokenConverter();
        } else {
            accessTokenConverter = new DefaultAccessTokenConverter();
        }
        return accessTokenConverter;
    }

    /**
     * 认证服务端JwtAccessTokenConverter配置
     * JWT令牌转换器，将令牌转换为JWT
     * 如果使用了JWT，需要添加@Bean，不然在org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter#decode(java.lang.String)中
     * Jwt jwt = JwtHelper.decodeAndVerify(token, verifier);verifier为空从而解码失败Cannot convert access token to JSON
     * 原理是JwtAccessTokenConverter实现了InitializingBean，afterPropertiesSet中对verifier = new MacSigner(verifierKey);进行赋值
     * 如果不添加bean，则InitializingBean不会加载afterPropertiesSet。
     * ConditionalOnMissingBean=》当指定类型的Bean不存在时才创建一个新的Bean
     * 参照源码手动设置密钥：{@link ResourceServerTokenServicesConfiguration.JwtTokenServicesConfiguration#jwtTokenEnhancer()}
     */
    @Bean
    @ConditionalOnMissingBean(DefaultAccessTokenConverter.class)
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        // 对称加密签名令牌，资源服务器也需要配置，用于验签，这里在application-security_oauth2_resource.yml配置文件中配置了
        Oauth2ConfigProperties.JwtKey jwtKey = oauth2ConfigProperties.getJwtKey();
        if (jwtKey.isAuthorized()) {
            Oauth2ConfigProperties.JwtKey.Authorization authorization = jwtKey.getAuthorization();
            if (null == authorization) {
                throw new BusinessException("Jwt密钥配置有误，若开启jwt功能需要配置加密签名或者加密密钥");
            }
            if (authorization.isSymmetric()) {
                converter.setSigningKey(authorization.getSigningKey());
            } else {
                // 生成密钥：alias别名，keypass密码
                // keytool -genkeypair -alias oauth2 -keyalg RSA -keypass oauth2 -keystore oauth2.jks -storepass oauth2
                // 第一个参数是密钥文件，第二个参数是密钥密码
                KeyStoreKeyFactory factory = new KeyStoreKeyFactory(new ClassPathResource(
                        authorization.getKeyPath()), authorization.getPass().toCharArray());
                // 别名
                converter.setKeyPair(factory.getKeyPair(authorization.getAlias()));
            }
        } else {
            // 注意，客户端密钥测试的话，需要客户端使用DefaultTokenServices对应tokenStore验签。
            Oauth2ConfigProperties.JwtKey.Client client = jwtKey.getClient();
            if (null != client) {
                if (client.isSymmetric()) {
                    converter.setSigningKey(client.getSigningKey());
                } else {
                    ClassPathResource resource = new ClassPathResource(client.getPublicKeyFilePath());
                    String publicKey = null;
                    try {
                        publicKey = IOUtils.toString(resource.getInputStream(), "UTF-8");
                    } catch (IOException e) {
                        log.error("读取公钥失败", e);
                    }
                    converter.setVerifierKey(publicKey);
                }
            } else {
                // 客户端没配置公钥信息则调用服务端接口获取
                String keyFromServer = getKeyFromServer();
                log.info("从服务端获取公钥:{}", keyFromServer);
                converter.setVerifierKey(keyFromServer);
            }
        }
        return converter;
    }

    /**
     * 从服务端获取公钥，参考:
     * {@link ResourceServerTokenServicesConfiguration.JwtTokenServicesConfiguration#getKeyFromServer()}
     */
    private String getKeyFromServer() {
        HttpHeaders headers = new HttpHeaders();
        String username = resourceServerProperties.getClientId();
        String password = resourceServerProperties.getClientSecret();
        if (username != null && password != null) {
            byte[] token = Base64.getEncoder()
                    .encode((username + ":" + password).getBytes());
            headers.add("Authorization", "Basic " + new String(token));
        }
        HttpEntity<Void> request = new HttpEntity<>(headers);
        String url = resourceServerProperties.getJwt().getKeyUri();
        return (String) Objects.requireNonNull(restTemplate()
                        .exchange(url, HttpMethod.GET, request, Map.class).getBody())
                .get("value");
    }


    /**
     * 手动创建SimpleClientHttpRequestFactory，指定超时时间以及代理配置
     */
    private SimpleClientHttpRequestFactory getSimpleClientFactory() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setReadTimeout(restTemplateProperties.getReadTimeout());
        factory.setConnectTimeout(restTemplateProperties.getConnectionTimeout());
        RestTemplateProperties.Proxy proxy = restTemplateProperties.getProxy();
        if (proxy.getEnabled()) {
            SocketAddress address = new InetSocketAddress(proxy.getHost(), proxy.getPort());
            factory.setProxy(new Proxy(Proxy.Type.HTTP, address));
        }
        return factory;
    }

    /**
     * oauth2.scope权限表达式解析
     */
    @Bean
    public OAuth2MethodSecurityExpressionHandler oAuth2MethodSecurityExpressionHandler() {
        return new OAuth2MethodSecurityExpressionHandler();
    }

    /**
     * 权限不足处理器
     */
    @Bean
    public AccessDeniedHandler accessDeniedHandler() {
        return new AccessDeniedHandler();
    }

    /**
     * 基于数据库存储客户端令牌
     */
    @Bean
    public JdbcClientTokenServices clientTokenServices() {
        return new JdbcClientTokenServices(dataSource);
    }
}
````

- 由于内存模式，用户对象是org.springframework.security.core.userdetails.User，token扩展添加一个类型判断：

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/src/main/java/com/cmmplb/oauth2/resource/server/impl/TokenEnhancerImpl.java`

````java
package com.cmmplb.oauth2.resource.server.impl;

import com.cmmplb.oauth2.resource.server.bean.User;
import org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.TokenEnhancer;

import java.util.HashMap;
import java.util.Map;

/**
 * @author penglibo
 * @date 2024-07-26 17:33:04
 * @since jdk 1.8
 * 拓展token信息
 */
public class TokenEnhancerImpl implements TokenEnhancer {

    @Override
    public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {
        final Map<String, Object> additionalInfo = new HashMap<>(2);
        if (null != authentication.getUserAuthentication()) {
            Object principal = authentication.getUserAuthentication().getPrincipal();
            if (principal instanceof User) {
                // 添加用户id字段
                additionalInfo.put(User.COLUMN_USER_ID, ((User) principal).getId());
            }
        }
        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);
        return accessToken;
    }
}
````

- 这里把系统模块的application-security_oauth2.yml配置拆分一下

拆分成application-security_oauth2_client.yml和application-security_oauth2_resource.yml

`spring-cloud-oauth2/spring-cloud-oauth2-system-server/src/main/resources/config/application-security_oauth2_client.yml`

````yaml
security:
  oauth2:
    client:
      # 客户端id
      client-id: system-server
      # 客户端密钥, 注意数据库存储的时候需要加密
      client-secret: 123456
````

`spring-cloud-oauth2/spring-cloud-oauth2-system-server/src/main/resources/config/application-security_oauth2_resource.yml`

````yaml
security:
  oauth2:
    resource:
      # 资源id
      id: system-server
      # token-info-uri和user-info-uri配置其中一个就行, 同时配置的话则看prefer-token-info
      # 使用RemoteTokenServices远程调用认证中心接口校验token获取用户认证信息-OAuth2Authentication
      token-info-uri: http://spring-cloud-oauth2-auth-server/oauth/check_token
      # 使用token-info-uri模式, 默认为true
      prefer-token-info: false
      # 使用UserInfoTokenServices远程调用认证中心接口获取当前用户认证信息-OAuth2Authentication
      user-info-uri: http://spring-cloud-oauth2-auth-server/user/info
      jwt:
        key-uri: http://spring-cloud-oauth2-auth-server/oauth/token_key
````

同时添加配置文件application-security_oauth2.yml

````yaml
security:
  oauth2:
    # 是否使用DefaultTokenServices
    default-token-services: false
    # 令牌存储类型: IN_MEMORY, JDBC, JWT, REDIS
    tokenStoreType: JWT
    # Jwt密钥配置
    jwt-key:
      # 客户端密钥配置
      client:
        # 是否对称加密, 默认为true
        symmetric: false
        # 对称加密签名密钥
        signing-key: cmmplb
        # 非对称加密公钥文件路径
        public-key-file-path: key/public.txt
````

资源模块添加公钥文件

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/src/main/resources/key/public.txt`

````
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzQWxPAtMeaE/6YbHuyJp
WENqql4/3Ey5IWWiSr05pJfiPb7vqKqieWLkVZ2v5Cth2VZ7KWWjJKuV6riPwJFh
gridjqWAZlKYU0NorX0MXY0Xqu4drnbOUf3Dfb3OdPRV/4PVgNQ3xE5VnvYVk2+/
VfhK31iWtzWH33AotpVfSxNvquBr0PevZxoEkxrcpOsCl1fVXMHVsnu4DjwxnBEM
+RLUW4YF+8PYDhC691xw62+/iHnlh7JEF5s3sDj2WsQFSgHXhjL39uSoGWV1TD88
DxvRAza9MaAWCwo6LFalGRNspC783T+vpO37/7Ez8PDKfwTCkhPYquXVDIrmFWH3
/QIDAQAB
-----END PUBLIC KEY-----
````

bootstrap.yml引用配置文件

````yaml
spring:
  profiles:
    # 引用配置文件
    include:
      - security_oauth2
      - security_oauth2_client
      - security_oauth2_resource
````

资源pom文件添加resource配置

`spring-cloud-oauth2/spring-cloud-oauth2-resource-server/pom.xml`

````xml

<build>
    <resources>
        <resource>
            <directory>src/main/resources</directory>
            <filtering>true</filtering>
            <excludes>
                <exclude>**/*.jks</exclude>
            </excludes>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
            <filtering>false</filtering>
            <includes>
                <include>**/*.jks</include>
            </includes>
        </resource>
    </resources>
</build>
````

配置完之后，重启系统模块和认证模块，通过修改application-security_oauth2.yml配置文件中的类型测试各种模式。

**公钥端点**

上面公钥是配置在资源服务，密钥存储在两处地方很难管理，公钥会定期修改，oauth提供了一个token_key的密钥端点，只不过是拦截的

源码：AuthorizationServerSecurityConfigurer.tokenKeyAccess

````
private String tokenKeyAccess = "denyAll()";

private String checkTokenAccess = "denyAll()";
````

在AuthorizationServerConfiguration中放行

`com.cmmplb.oauth2.auth.server.configuration.AuthorizationServerConfiguration`

````java
public class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {

    /**
     * 配置令牌端点(Token Endpoint)的安全约束
     */
    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) {
        security
                // 允许客户端表单验证，默认false
                .allowFormAuthenticationForClients()
                // 允许校验token请求，默认denyAll()
                .checkTokenAccess("permitAll()")
                // 允许获取公钥请求，默认denyAll()
                .tokenKeyAccess("isAuthenticated()")
        ;
    }
}
````

重启认证服务，访问http://localhost:10000/auth/oauth/token_key接口。

````shell
curl --location 'http://localhost:10000/auth/oauth/token_key' \
--header 'Authorization: Basic d2ViOjEyMzQ1Ng=='
````

结果：

````json
{
  "alg": "SHA256withRSA",
  "value": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzQWxPAtMeaE/6YbHuyJpWENqql4/3Ey5IWWiSr05pJfiPb7vqKqieWLkVZ2v5Cth2VZ7KWWjJKuV6riPwJFhgridjqWAZlKYU0NorX0MXY0Xqu4drnbOUf3Dfb3OdPRV/4PVgNQ3xE5VnvYVk2+/VfhK31iWtzWH33AotpVfSxNvquBr0PevZxoEkxrcpOsCl1fVXMHVsnu4DjwxnBEM+RLUW4YF+8PYDhC691xw62+/iHnlh7JEF5s3sDj2WsQFSgHXhjL39uSoGWV1TD88DxvRAza9MaAWCwo6LFalGRNspC783T+vpO37/7Ez8PDKfwTCkhPYquXVDIrmFWH3/QIDAQAB\n-----END PUBLIC KEY-----"
}
````

之后客户端添加这个key-uri配置，公钥则用认证服务端颁发。

````yaml
security:
  oauth2:
    resource:
      jwt:
        key-uri: http://localhost:@gateway.server.port@/auth/oauth/token_key
````

同时把application-security_oauth2.yml中的Jwt密钥配置注释，客户端不配置jwt信息的话，密钥则通过认证服务器获取。

`spring-cloud-oauth2/spring-cloud-oauth2-system-server/src/main/resources/config/application-security_oauth2.yml`

````yaml
security:
  oauth2:
    # 是否使用DefaultTokenServices，用于测试客户端验证jwt
    default-token-services: true
    # 令牌存储类型: IN_MEMORY, JDBC, JWT, REDIS
    tokenStoreType: JWT
    # Jwt密钥配置
#    jwt-key:
#      # 客户端密钥配置
#      client:
#        # 是否对称加密, 默认为true
#        symmetric: false
#        # 对称加密签名密钥
#        signing-key: cmmplb
#        # 非对称加密公钥文件路径
#        public-key-file-path: key/public.txt
````

**密钥生成**

keytool命令的功能是用于管理密钥和证书文件。

常用参数

| 命令              | 备注              |
|-----------------|-----------------|
| -certreq        | 生成证书请求          |
| -changealias    | 更改条目的别名         |
| -delete         | 删除条目            |
| -exportcert     | 导出证书            |
| -genkeypait     | 生成密钥对           |
| -genseckey      | 生成密钥            |
| -gencert        | 根据证书请求生成证书      |
| -importcert     | 导入证书或证书链        |
| -importkeystore | 从其他密钥库导入一个或所有条目 |
| -keystore       | 证书保存位置          |
| -keyalg         | 指定加密算法          |
| -keypasswd      | 更改条目的密钥口令       |
| -list           | 列出密钥库中的条目       |
| -printcert      | 打印证书内容          |
| -printcertreq   | 打印证书请求的内容       |
| -printcrl       | 打印CRL文件的内容      |
| -storepasswd    | 更改密钥库的存储口令      |

- jdk安装bin目录下执行命令生成密钥：

别名为oauth2，密钥口令为oauth2，保存位置为当前目录下的oauth2.jks，更改密钥库的存储口令为oauth2

- 生成密钥

````shell
keytool -genkeypair -alias oauth2 -keyalg RSA -keypass oauth2 -keystore oauth2.jks -storepass oauth2
````

- 通过密钥生成公钥，口令是oauth2

````shell
keytool -list -rfc --keystore oauth2.jks | openssl x509 -inform pem -pubkey
````

````
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzQWxPAtMeaE/6YbHuyJp
WENqql4/3Ey5IWWiSr05pJfiPb7vqKqieWLkVZ2v5Cth2VZ7KWWjJKuV6riPwJFh
gridjqWAZlKYU0NorX0MXY0Xqu4drnbOUf3Dfb3OdPRV/4PVgNQ3xE5VnvYVk2+/
VfhK31iWtzWH33AotpVfSxNvquBr0PevZxoEkxrcpOsCl1fVXMHVsnu4DjwxnBEM
+RLUW4YF+8PYDhC691xw62+/iHnlh7JEF5s3sDj2WsQFSgHXhjL39uSoGWV1TD88
DxvRAza9MaAWCwo6LFalGRNspC783T+vpO37/7Ez8PDKfwTCkhPYquXVDIrmFWH3
/QIDAQAB
-----END PUBLIC KEY-----
-----BEGIN CERTIFICATE-----
MIIDTTCCAjWgAwIBAgIEbnoJozANBgkqhkiG9w0BAQsFADBXMQswCQYDVQQGEwJj
aDELMAkGA1UECBMCZ3oxCzAJBgNVBAcTAmd6MQ8wDQYDVQQKEwZjbW1wbGIxDzAN
BgNVBAsTBmNtbXBsYjEMMAoGA1UEAxMDcGxiMB4XDTI0MDgwMTA4NDg1MloXDTI0
MTAzMDA4NDg1MlowVzELMAkGA1UEBhMCY2gxCzAJBgNVBAgTAmd6MQswCQYDVQQH
EwJnejEPMA0GA1UEChMGY21tcGxiMQ8wDQYDVQQLEwZjbW1wbGIxDDAKBgNVBAMT
A3BsYjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM0FsTwLTHmhP+mG
x7siaVhDaqpeP9xMuSFlokq9OaSX4j2+76iqonli5FWdr+QrYdlWeylloySrleq4
j8CRYYK4nY6lgGZSmFNDaK19DF2NF6ruHa52zlH9w329znT0Vf+D1YDUN8ROVZ72
FZNvv1X4St9Ylrc1h99wKLaVX0sTb6rga9D3r2caBJMa3KTrApdX1VzB1bJ7uA48
MZwRDPkS1FuGBfvD2A4QuvdccOtvv4h55YeyRBebN7A49lrEBUoB14Yy9/bkqBll
dUw/PA8b0QM2vTGgFgsKOixWpRkTbKQu/N0/r6Tt+/+xM/Dwyn8EwpIT2Krl1QyK
5hVh9/0CAwEAAaMhMB8wHQYDVR0OBBYEFCHfVyXqGbUmQPWMWlhJ8JNrxtywMA0G
CSqGSIb3DQEBCwUAA4IBAQCE5PX50Jny552C+g+cfjYVPlMSTAsgmZazpfyhC8kd
VMSb4eTeDZaLr7mT86lykEZ7UF+POeyTqxP2gmzKXhIxsEtSrLKjsfS4l0gffUiY
0/0Xif447FAehe3m9a0ESGAyFFNlpHsBJ71IzWKH/rzLijr8Rd7reqHT+F8qKz6E
ytI0TMV8TsDgBIdtWACRK0wXsBVpZLrCPZmP0Ftg/uInCxQkYE8w4jcQ/62h8PCe
eQyETRKtocmQG3NGnjDJTXX+cXQVHYb2RfloswNIImK2Q6UBi8CYB+yn6gqFOnVh
mcHcIZz5opkXHuRhkPA/vn/haf2rMlBzilmOdFrCp7me
-----END CERTIFICATE-----
````

之后回答问题之后在执行命令的路径下生成oauth2.jks，复制到项目的resources/key目录下

- 生成一个指定名称的证书文件，加密类型为RSA，有效期365天：

````shell
keytool -genkey -alias tomcat -keyalg RSA -keystore /etc/tomcat.keystore -validity 365
````

- 导入一个指定名称的证书文件，定义别名名称：

````shell
keytool -import -keystore cacerts -storepass 666666 -keypass 888888 -alias linuxcool -file /etc/tomcat.keystore
````

- 删除一个指定名称的证书：

````shell
keytool -delete -alias linuxcool -keystore cacerts -storepass 666666
````